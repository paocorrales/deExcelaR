---
title: "Manipulación de datos ordenados usando {dplyr} y {tidyr} II"
output: 
  html_document:
    code_download: true
    toc: true
    toc_float: true
    template: "_template.html"    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


En [la última sección de lectura de datos](04-lectura-datos.html#Formatos_de_tablas) viste el concepto de datos "anchos" y "largos". 

Los datos en formato "largo" o "tidy", son aquellos en los cuales 

* cada fila es una observación
* cada columna es una variable

En el formato "ancho" es un poco más complejo de definir pero la idea general es que:

* cada fila es un "item"
* cada columna es una variable

![](img/largo-ancho.png)

Una tabla en formato largo va a tener una cierta cantidad de columnas que cumplen el rol de identificadores y cuya combinación identifican una única observación y una única columna con el valor de la observación. En el ejemplo de arriba, "pais" y "anio" son las columnas identificadoras y "casos" es la columna que contiene el valor de las observaciones. 

En una tabla larga, cada observación única se identifica a partir de la intersección de filas y columnas. En el ejemplo, los países están en las filas y los años en las columnas. 

En general, el formato ancho es más compacto y legible por humanos mientras que el largo es más fácil de manejar con la computadora. Si te fijás en las tablas de arriba, es más fácil comparar los valores entre paises y entre años en la tabla ancha. Pero el nombre de las columnas ("1999", "2000") en realidad ¡son datos! Además este formato se empieza a complicar en cuanto hay más de dos identificadores. 

Un mismo set de datos puede ser representado de forma completamente "larga", completamente "ancha" o --lo que es más común-- en un formato intermedio pero no existe una forma "correcta" de organizar los datos; cada una tiene sus aplicaciones. Por esto es que es muy normal que durante un análisis los datos vayan y vuelvan entre distintos formatos dependiendo de los métodos estadísticos que se le aplican. Entonces, aprender a transformar datos anchos en largos y viceversa es un habilidad muy útil. 


::: {.alert .alert-info}
**Desafío**

En las tablas de ejemplo cada país tiene el un valor observado de "casos" para cada año. ¿Cómo agregarías una nueva variable con información sobre "precios"? Dibujá un esquema en papel y lápiz en formato ancho y uno en formato largo. ¿En qué formato es más "natural" esa extensión?

:::


En esta sección vas a usar el paquete {tidyr} para manipular datos. Si no lo tenés instalado, instalalo con el comando:

```{r eval = FALSE}
install.packages("tidyr")
```

(como siempre, recordá que esto hay que hacerlo una única vez)

Y luego cargá {tidyr} y {dplyr} (que usaste en [una sección anterior](05-dplyr-I.html)) usando 

```{r}
library(tidyr)
library(dplyr)
```

## De ancho a largo con `pivot_longer()`

En secciones anteriores usaste una versión de los datos de [gapminder](https://www.gapminder.org/). Ahora vas a leer los datos en su formato original:

```{r}
paises_ancho <- readr::read_csv("datos/paises_ancho.csv")
paises_ancho
```

::: {.alert .alert-success}

¿Notaste que en el código anterior no usaste `library(readr)` para cargar el paquete y luego leer? Con la notación `paquete::funcion()` podés acceder a las funciones de un paquete sin tener que cargarlo. Es una buena forma de no tener que cargar un montón de funciones innecesarias si vas a correr una función de un paquete pocas veces. 

:::


Esta tabla, increíblemente ancha, es muy difícil de manejar. Por ejemplo, es imposible hacer una serie de tiempo de una variable, o calcular el promedio por variable y país; ni hablar de calcular una regresión lineal. 

Para convertirlo en una tabla más larga, se usa `pivot_longer()` ("longer" es "más largo" en inglés):

```{r}
paises_largo <- pivot_longer(paises_ancho,
                             cols = c(starts_with('pob'), 
                                      starts_with('esperanza'), 
                                      starts_with('pib_per')),
                             names_to = "variable_anio", 
                             values_to = "valor"
)
paises_largo
```

El primer argumento de`pivot_longer()` es la tabla que va a modificar: `paises_ancho`. El segundo argumento se llama `cols` y es un vector con las columnas que tienen los valores a "alargar". Podría ser un vector escrito a mano (algo como `c("pib_per_capita_1952", "pib_per_capita_1957"...)`) pero con más de 30 columnas, escribir todo eso sería tedioso y probablemente estaría lleno de erorres. Por eso {tidyr} provee funciones de ayuda para seleccionar columnas en base a patrones. El código de arriba usa `starts_with()` que, como su nombre en inglés lo indica, selecciona las columnas que empiezan con una determinada cadena de caracteres. El vector `c(starts_with('pob'), starts_with('esperanza'), starts_with('pib_per'))` le dice a `pivot_longer()` que seleccione las columnas que empieza con "pob", las que empiezan con "esperanza" y las que empiezan con "pib_per". 

::: {.alert .alert-success}

Estas funciones accesorias para seleccionar muchas funciones se llaman "tidyselect". Si querés leer más detalles de las distintas formas que podés seleccionar variables leé la documentación usando `?tidyselect::language`.

:::

El tercer y cuarto argumento son los nombres de las columnas de "nombre" y de "valor" que va a tener la nueva tabla. Como la nueva columna de identificación tiene los datos de la variable y el año a medir, "variable_anio" es un buen nombre. Y la columna de valor va a tener... bueno, el valor. 

Tomate un momento para visualizar lo que acaba de pasar. La tabla ancha tenía un montón de columnas con distintos datos. Ahora estos datos están uno arriba de otro en la columna "valor", pero para identificar el nombre de la columna de la cual vinieron, se agrega la columna "variable_anio". 


![Proceso de largo a ancho](img/ancho-a-largo.png)

La columna `variable_anio` todavía no es muy útil porque contiene 2 datos, la variable (población, expectativa de vida o PBI per cápita) y el año. Sería mejor separar esta información en dos columnas llamadas "variable" y "anio". Para eso está la función `separate`

```{r}
separate(paises_largo, 
         col = variable_anio, 
         into = c("variable", "anio"), 
         sep = -4)
```

El primer argumento, como siempre, es la tabla a procesar. El segundo, `col`, es la columna a separar en dos (o más). El tercero, `into` es el nombre de las nuevas columnas que `separate()` va a crear. El último argumento es `sep` que define cómo realizar la separación. Por defecto, `sep` es una [expresión regular](https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular) que cpatura cualquier caracter no alfanumérico. En el caso de `variable_anio` no sirve, porque para valores como `"esperanza_de_vida_1952"`, separaría en `"esperanza"`, `"de"`, `"vida"` y `"1952"`. Como el año tiene siempre 4 caracteres, una solución simple es usar `sep = -4`, que significa que la separacion es 4 caracteres contando desde el final. 

Habrás notado un problema. El texto en la columnas `variable` toavía tiene un "_" al final. Podrías usar `mutate()` y un poco de funciones de manipulación de caracteres para quitarlo, pero hay una forma un poco más simple y es separando la columna `vriable_anio` en tres, incluyendo una columna con el guión:

```{r}
paises_largo <- separate(paises_largo, 
         col = variable_anio, 
         into = c("variable", "guion", "anio"), 
         sep = c(-5, -4))
paises_largo
```

Y ya casi. Hay que eliminar la columna `guion`, que no sirve para nada. Pero fijate que debajo de la columna `anio` dice `<chr>`; eso significa que el tipo de la columna es caracter, pero los años son números. Usando `mutate()` podés eliminar la columna `guion` asignándole el valor `NULL` (nulo) y coercer (recordá [esta sección](04-lectura-datos.html#Vectores)) la columna `anio` a entero usando `as.integer()`:

```{r}
paises_largo <- mutate(paises_largo, 
                       guion = NULL,
                       anio = as.integer(anio))
paises_largo
```

::: {.alert .alert-info}
**Desafío**

Juntá todos los pasos anteriores en una sola cadena de operaciones usando `%>%`.

:::



## De largo a ancho con `pivot_wider()`

Ahora la variable `paises_largo` está en el formato más largo posible. Tiene 5 columnas, de las cuales sólo una es la columnas con valores. Pero con los datos así no podrías hacer un gráfico de puntos que muestre la relación entre el PBI per cápita y la expectativa de vida como en la [sección de gráficos](06-graficos-I.html#Segunda_capa:_geometrías). Fijate que los valores de la columna `valor` no tienen todos las mismas unidades, por lo que operar con ese vector podría dar resultados sin sentido. Muchas veces es conveniente y natural tener los datos en un formato intermedio en donde hay múltiples columnas con los valores de distintas variables observadas. 

Pasa "ensanchar" una tabla está la función `pivot_wider()` ("wider" es "más ancha" en inglés) y el código para conseguir este formato intermedio es:

```{r}
paises_medio <- pivot_wider(paises_largo, names_from = variable, values_from = valor)
paises_medio
```

Nuevamente el primer argumento es la tabla original. El segundo, `names_from` es la columna cuyos valores únicos van a convertirse en nuevas columnas. La columna `variable` tiene los valores `"población"`, `"esperanza_de_vida"` y `"pib_per_capita"` y entonces la tabla nueva tiene tres columnas con esos nombres. El tercer argumento, `values_from`, es la columna de la cual sacar los valores. 

Para volver al formato más ancho, basta con agregar más columnas en el argumento `names_from`:

```{r}
pivot_wider(paises_largo, 
            names_from = c(variable, anio), 
            names_sep = "_",
            values_from = valor)
```

En esta llamada también está el argumento `names_sep`, que detemrina el caracter que se usa para crear el nombre de las nuevas columnas. 


::: {.alert  .alert-info}
**Desafio**

* Creá una nueva tabla, llamada `paises_superduper_ancho` que tenga una columna para cada variable, anio y país. (Consejo: la tabla final tiene que tener 5 filas).


* ¿Cómo es la tabla más ancha posible que podés generar con estos datos? ¿Cuántas filas y columnas tiene?

:::




